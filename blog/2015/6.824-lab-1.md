Lab 1 - Distributed Systems (6.824)
===

[第十一期周报](https://github.com/dyweb/web-stuff/blob/master/weekly/2015/1216.md) 里被 [@at15](https://github.com/at15) [安利](https://github.com/dyweb/web-stuff/issues/24#issuecomment-164697606) 了 [MIT的分布式课程](https://pdos.csail.mit.edu/6.824/index.html), 于是跟着 [@gaocegege][gaocegege] 开了坑......

[gaocegege]: https://github.com/gaocegege

> 围观策策请移步 [gaocegege/6.824-Distributed-Systems-Lab](https://github.com/gaocegege/6.824-Distributed-Systems-Lab)~

## Go

配置环境花了好久... 因为想要一个 REPL, 找了 [motemen/gore](https://github.com/motemen/gore); 然后发现 `go get` 拉不下来; 用 proxychains 挂 ss 似乎也有问题; 再换 [gopm](http://gopm.io/); 然而也拉不下来... (不科学!) 后来某天再试突然又好了......

总之先入门 Go. 直接有用的文档:
- Example from [string.FieldsFunc][string.FieldsFunc]
- [Arrays, Slices and Maps][golang.intro/ch6] (以及 [An Introduction to Programming in Go](https://www.golang-book.com/books/intro) 的其他章节)
- [Package list][list]

[string.FieldsFunc]: https://golang.org/pkg/strings/#FieldsFunc
[golang.intro/ch6]: https://www.golang-book.com/books/intro/6
[list]: https://golang.org/pkg/container/list/

零 Go 基础的话, 看完这些也可以开始 [Lab 1](https://pdos.csail.mit.edu/6.824/labs/lab-1.html) Part I 了.

## Part I

一开始没有看整个结构. 只看要修改的部分:

```go
// our simplified version of MapReduce does not supply a
// key to the Map function, as in the paper; only a value,
// which is a part of the input file content. the return
// value should be a list of key/value pairs, each represented
// by a mapreduce.KeyValue.
func Map(value string) *list.List {
}

// called once for each key generated by Map, with a list
// of that key's string value. should return a single
// output value for that key.
func Reduce(key string, values *list.List) string {
}
```

感觉上是,
- `Map` 接收一段原始文本, 返回按词分割的结果组成的 `list`, 每个元素是一个 mapreduce.KeyValue 结构; (结构体含 `Key` 和 `Value` 两个 `string`, 这里 `Value` 应该都是 `"1"`, 不用考虑重复的 `Key`.)
- `Reduce` 接收一个 `key` 和 **具有这个 `Key` 的所有 `Value` 组成的 `list`**, 返回这些 `Value` 合并后的结果. (合并方法就是直接相加.)

按提示, `Map` 就直接抄 [string.FieldsFunc][string.FieldsFunc] 的例子来分词, 再建个新 `list`, 然后抄 [Arrays, Slices and Maps][golang.intro/ch6] 里遍历数组的例子, 挨个加入元素, 如下.

```go
func Map(value string) *list.List {
  // Split string into words.
  words := strings.FieldsFunc(value, func(c rune) bool {
    return !unicode.IsLetter(c) && !unicode.IsNumber(c)
  })
  // Map each word to a key-value pair.
  pairs := list.New()
  for _, word := range words {
    pairs.PushBack(mapreduce.KeyValue{word, "1"})
  }
  return pairs
}
```

`Reduce` 要用到 [Package strconv](https://golang.org/pkg/strconv/) 来互转 `string` 和 `int` 了. 另外, 由于要遍历 `list` 中的元素 (抄 [Package list][list] 里 Overview 的遍历), 得确定一下每个元素的类型, 即 [Type Assertion](http://stackoverflow.com/questions/14289256/cannot-convert-data-type-interface-to-type-string-need-type-assertion) 的问题. 如下.

```go
func Reduce(key string, values *list.List) string {
  total := 0
  for e := values.Front(); e != nil; e = e.Next() {
    delta, _ := strconv.Atoi(e.Value.(string))
    total += delta
  }
  return strconv.Itoa(total)
}
```

写到这儿就可以到 `~/src/main` 下跑 `. ./test-wc.sh` 了, 出 `Passed test` 就算结束 Part I 了.

## Part II & Part III

到 Part II 感觉好难... 于是参~~chɑ̄o~~考~~xí~~了 [@gaocegege][gaocegege] 的 [MIT分布式系统Lab1分享](http://gaocegege.com/Blog/distributed%20system/ds-lab1/).

然后发现需要阅读:
- [Go statements](https://golang.org/ref/spec#Go_statements)
- [Channels](https://gobyexample.com/channels) & [Channel Buffering](https://gobyexample.com/channel-buffering)

根据以上写了个例子:

```go
package main

import "fmt"

func main() {
  messages := make(chan string, 2)
  words := []string{"a", "b", "c", "d"}
  for i, w := range words {
    go func(index int, word string) {
      fmt.Println("Sending", index, "with", word)
      messages <- word
      fmt.Println("-- Sent", index, "with", word)
    }(i, w)
  }
  for i, _ := range words {
    fmt.Println("Receive", i, " as ", <- messages)
  }
}
```

输出如下:

```
$ go run channel.go
Sending 0 with a
-- Sent 0 with a
Sending 1 with b
-- Sent 1 with b
Sending 2 with c
Sending 3 with d
Receive 0  as  a
Receive 1  as  b
-- Sent 2 with c
-- Sent 3 with d
Receive 2  as  c
Receive 3  as  d
```

然后~~一边参考 [@gaocegege][gaocegege] 的分享一边~~再回头看 Part II, 梳理一下:
- 需要改的是 `~/src/mapreduce/master.go` 中的 `RunMaster` 函数, 需要做的是,
  + 给 `mr.nMap` 个 Worker 分发 Map 任务,
  + 全部完成后, 再给 `mr.nReduce` 个 Worker 分发 Reduce 任务,
  + 全部完成后, 执行原来的 `return mr.KillWorkers()`;
- Worker 不需要我们来注册, 参考 `~/src/mapreduce/mapreduce.go` 中的 `Register` 函数, 我们只需要 `worker := <- mr.registerChannel` 等着就可以了.

所以结构上差不多就是上面那个例子重复两遍. 重点是, 执行 `worker := <- mr.registerChannel` 后如何给这个 Worker 分发任务, 这里我们参~~chɑ̄o~~考~~xí~~了 [@gaocegege][gaocegege] 的代码: `call(worker, "Worker.DoJob", &DoJobArgs{...}, &DoJobReply{})`. (这里必须用 `&`...)

然后就简单了, 按 `~/src/mapreduce/common.go` 中的 `DoJobArgs` 的结构, 需要分别填入 `mr.file`, `Map` 或 `Reduce`, 任务编号, 另一批任务的数量 (Map 时就是 Reduce 的数量, 反之同理). 代码如下:

```go
func (mr *MapReduce) Handle(selfSize int, otherSize int, operation JobType) {
  doneChannel := make(chan int, selfSize)
  for i := 0; i < selfSize; i++ {
    go func (jobNumber int) {
      for { // 不断尝试执行, 直到 call 成功返回 true. 这里其实就完成了 Part III 的要求.
            // 由于任务的简单性, 不需要考虑单个任务失败(或失联)了怎么处理, 直接重新再来一遍就行.
        worker := <- mr.registerChannel
        if call(worker, "Worker.DoJob", &DoJobArgs{mr.file, operation, jobNumber, otherSize}, &DoJobReply{}) {
          mr.registerChannel <- worker // 归还空闲 worker
          doneChannel <- jobNumber
          return
        }
      }
    }(i)
  }
  for i := 0; i < selfSize; i++ {
    fmt.Println(operation, "Job", <- doneChannel, "done")
  }
}

func (mr *MapReduce) RunMaster() *list.List {
  mr.Handle(mr.nMap, mr.nReduce, Map)
  mr.Handle(mr.nReduce, mr.nMap, Reduce)
  return mr.KillWorkers()
}
```

为了避免 `mr.registerChannel` 阻塞, 顺便到 `~/src/mapreduce/mapreduce.go` 的 `InitMapReduce` 里改了它的初始化:

```go
// 之前要 import "math"
mr.registerChannel = make(chan string, int(math.Max(float64(nmap), float64(nreduce))))
```

~~求问这个取较大值怎么写能优雅一点......~~

然后到 `~/src/mapreduce` 下跑 `go test`, 出 `PASS` 就可以了.

## 结

Lab 1 算是重拾了遍地类型的感觉... (js/php/python写惯了...) 然后熟悉了一下 go 的各种语法, 嗯.

> channel 和 go statement 好棒!

到这里暂时先弃坑, 快期末了 -\_-...

2015/12/29
